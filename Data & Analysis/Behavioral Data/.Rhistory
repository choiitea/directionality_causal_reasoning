D$test_choice = rep(0,nrow(D))
for(i in 1:nrow(D)){
if(D$correct_soc_choice[i]==D$test_soc_choice[i]){
D$test_choice[i] = "Correct"
}else{
D$test_choice[i] = "Incorrect"
}
}
head(D$test_choice)
# get the distribution of correct and incorrect choices
table(D$test_choice)
table(D$correct_soc_choice)
table(D$test_soc_choice)
fix(D)
D$direction_choice = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice[i] = 0 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice[i] = 0 #chose inverse but not soc_con
}else{
D$direction_choice[i] = 0 #neither
}
}
D$direction_choice = NULL
D$direction_choice_lib = revalue(x = as.factor(D$direction_choice_lib),
c("0" = "Other", "1"="Order Consistent"))
D$direction_choice_lib = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice[i] = 0 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice[i] = 0 #chose inverse but not soc_con
}else{
D$direction_choice[i] = 0 #neither
}
}
table(D$direction_choice_lib)
D$direction_choice = NULL
D$direction_choice_lib = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice_lib[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice_lib[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice_lib[i] = 0 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice_lib[i] = 0 #chose inverse but not soc_con
}else{
D$direction_choice_lib[i] = 0 #neither
}
}
D$direction_choice_lib = revalue(x = as.factor(D$direction_choice_lib),
c("0" = "Other", "1"="Order Consistent"))
# get the distribution of "order consistent" and "choices"
# for the Direction test trial
table(D$direction_choice_lib)
D$direction_choice_conserv = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice_conserv[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice_conserv[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice_conserv[i] = 2 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice_conserv[i] = 2 #chose inverse but not soc_con
}else{
D$direction_choice_conserv[i] = 3 #neither
}
}
# get the distribution of choices for the conservative coding of
# direction
table(D$direction_choice_conserv)
# name the levels of direction_choice_conserv
D$direction_choice_conserv = revalue(x = as.factor(D$direction_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"2" = "Inverse", "3"= "Neither"))
table(D$direction_choice_conserv)
binom.test(14, 14+7, p=0.5, alternative="two.sided")
binom.test(14, 14+6, p=0.5, alternative="two.sided")
D$control_choice_lib = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$ordered_contrDir_choice[i]==D$test_contrDir_choice[i]){
D$control_choice_lib[i] = 1 #order-consistent
}else if(D$test_contrDir_choice[i]=="both"){
D$control_choice_lib[i] = 0
}else if(D$test_contrDir_choice[i]=="left"&&D$ordered_contrDir_choice[i]=="right"){
D$control_choice_lib[i] = 0 #chose inverse but not order_con
}else if(D$test_contrDir_choice[i]=="right"&&D$ordered_contrDir_choice[i]=="left"){
D$control_choice_lib[i] = 0 #chose inverse but not order_con
}else{
D$control_choice_lib[i] = 0 #neither
}
}
D$control_choice_lib = revalue(x = as.factor(D$control_choice_lib),
c("0" = "Other", "1"="Order Consistent"))
table(D$control_choice_lib)
D$control_choice_conserv = revalue(x = as.factor(D$control_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"2" = "Inverse", "3"= "Neither"))
D$control_choice_conserv = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$ordered_contrDir_choice[i]==D$test_contrDir_choice[i]){
D$control_choice_conserv[i] = 1 #order-consistent
}else if(D$test_contrDir_choice[i]=="both"){
D$control_choice_conserv[i] = 0
}else if(D$test_contrDir_choice[i]=="left"&&D$ordered_contrDir_choice[i]=="right"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else if(D$test_contrDir_choice[i]=="right"&&D$ordered_contrDir_choice[i]=="left"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else{
D$control_choice_conserv[i] = 3 #neither
}
}
D$control_choice_conserv = revalue(x = as.factor(D$control_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"2" = "Inverse", "3"= "Neither"))
# get distributional data
table(D$control_choice_conserv)
D$control_choice_conserv = revalue(x = as.factor(D$control_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"3"= "Neither"))
D$control_choice_conserv = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$ordered_contrDir_choice[i]==D$test_contrDir_choice[i]){
D$control_choice_conserv[i] = 1 #order-consistent
}else if(D$test_contrDir_choice[i]=="both"){
D$control_choice_conserv[i] = 0
}else if(D$test_contrDir_choice[i]=="left"&&D$ordered_contrDir_choice[i]=="right"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else if(D$test_contrDir_choice[i]=="right"&&D$ordered_contrDir_choice[i]=="left"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else{
D$control_choice_conserv[i] = 3 #neither
}
}
D$control_choice_conserv = revalue(x = as.factor(D$control_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"3"= "Neither"))
# get distributional data
table(D$control_choice_conserv)
names(D)
fix(D)
D = D[,c(1,10:15)]
D$ID = c(1:nrow(D))
rm(list=ls())
library(lme4)
library(nlme)
library(boot)
library(car)
library(reshape2)
library(ggplot2)
library(ez)
library(plyr)
library(ggsignif)
library(lsr)
library(sjmisc)
library(sjstats)
library(BayesFactor)
library(foreign)
library(dplyr)
library(lattice)
library(openxlsx)
library(sjPlot)
library(pwr)
library(nnet)
options(scipen=9999)
######################
# data preprocessing #
######################
## load data ##
D = read.csv(file.choose(), header = TRUE)
D$test_choice = rep(0,nrow(D))
for(i in 1:nrow(D)){
if(D$correct_soc_choice[i]==D$test_soc_choice[i]){
D$test_choice[i] = "Correct"
}else{
D$test_choice[i] = "Incorrect"
}
}
## get the distribution of correct and incorrect choices ##
table(D$test_choice)
# It should be clear that participants overwhelmingly chose
# the correct test object averaged over trials.
# And given that so few participants chose the "incorrect"
# test object (i.e., N = 6), we are justified to lump
# the non-correct responses together; that is, we are justified to lump
# "unsures" (N=4) with "incorrects" (N=2).
## create a direction_choice_lib variable ##
D$direction_choice_lib = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice_lib[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice_lib[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice_lib[i] = 0 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice_lib[i] = 0 #chose inverse but not soc_con
}else{
D$direction_choice_lib[i] = 0 #neither
}
}
# 0 - both; 1 - SOC_consistent; 2 - inverse but not soc_con; 3 - neither
# name the levels of direction_choice_lib
D$direction_choice_lib = revalue(x = as.factor(D$direction_choice_lib),
c("0" = "Other", "1"="Order Consistent"))
#  Note that this corresponds to a "liberal" coding of adults' responses
# to the direction trials.
# get the distribution of "order consistent" and "other" choices
# for the Direction test trial
table(D$direction_choice_lib)
# Here it's clear that participants are much less likely to choose the "order consistent" object
# compared to "other" choices. Of course, we'll follow this up, below, with formal analyses,
# but frequency distribution at least tells us that adults are *not* representing the SOCs directionally;
# that is, they appear to be insensitive to direction. I intend to test this with children to see
# if the same is true. Interesting stuff.
## create a direction_choice_conserv variable ##
D$direction_choice_conserv = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$test_dir_choice[i]==D$ordered_dir_choice[i]){
D$direction_choice_conserv[i] = 1 #soc-consistent / order-consistent
}else if(D$test_dir_choice[i]=="both"){
D$direction_choice_conserv[i] = 0
}else if(D$test_dir_choice[i]=="left"&&D$ordered_dir_choice[i]=="right"){
D$direction_choice_conserv[i] = 2 #chose inverse but not soc_con
}else if(D$test_dir_choice[i]=="right"&&D$ordered_dir_choice[i]=="left"){
D$direction_choice_conserv[i] = 2 #chose inverse but not soc_con
}else{
D$direction_choice_conserv[i] = 3 #neither
}
}
# 0 - both; 1 - SOC_consistent; 2 - inverse but not soc_con; 3 - neither
# name the levels of direction_choice_conserv
D$direction_choice_conserv = revalue(x = as.factor(D$direction_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"2" = "Inverse", "3"= "Neither"))
# get the distribution of choices for the conservative coding of
# direction
table(D$direction_choice_conserv)
# When participants' choices on the direction test trial are coded this way, it's
# clear that there is much more variability (necessarily). What's most interesting
# is that, ignoring the neither participants, participants were mostly split between
# choosing both objects as a blicket or only the order consistent:
# binom.test(14, 14+7, p=0.5, alternative="two.sided") > .05
## create a control_choice_lib variable ##
D$control_choice_lib = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$ordered_contrDir_choice[i]==D$test_contrDir_choice[i]){
D$control_choice_lib[i] = 1 #order-consistent
}else if(D$test_contrDir_choice[i]=="both"){
D$control_choice_lib[i] = 0
}else if(D$test_contrDir_choice[i]=="left"&&D$ordered_contrDir_choice[i]=="right"){
D$control_choice_lib[i] = 0 #chose inverse but not order_con
}else if(D$test_contrDir_choice[i]=="right"&&D$ordered_contrDir_choice[i]=="left"){
D$control_choice_lib[i] = 0 #chose inverse but not order_con
}else{
D$control_choice_lib[i] = 0 #neither
}
}
# name the levels of control_choice_lib
D$control_choice_lib = revalue(x = as.factor(D$control_choice_lib),
c("0" = "Other", "1"="Order Consistent"))
table(D$control_choice_lib)
# The frequency distribution data here shows that during the control trial,
# participants were far more likely not to choose the order consistent object
# than to respond some other way.
## create a control_choice_conserv variable ##
D$control_choice_conserv = rep(0, nrow(D))
for(i in 1:nrow(D)){
if(D$ordered_contrDir_choice[i]==D$test_contrDir_choice[i]){
D$control_choice_conserv[i] = 1 #order-consistent
}else if(D$test_contrDir_choice[i]=="both"){
D$control_choice_conserv[i] = 0
}else if(D$test_contrDir_choice[i]=="left"&&D$ordered_contrDir_choice[i]=="right"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else if(D$test_contrDir_choice[i]=="right"&&D$ordered_contrDir_choice[i]=="left"){
D$control_choice_conserv[i] = 2 #chose inverse but not order_con
}else{
D$control_choice_conserv[i] = 3 #neither
}
}
# 0 - both; 1 - order_consistent; 2 - inverse but not order_consistent; 3 - neither
# name the levels of direction_choice_conserv
D$control_choice_conserv = revalue(x = as.factor(D$control_choice_conserv),
c("0" = "Both", "1"="Order Consistent",
"3"= "Neither"))
# get distributional data
table(D$control_choice_conserv)
D = D[,-c(1,10:15)]
fix(D)
D$ID = c(1:nrow(D))
D$row.names = NULL
names(D_tall)
names(D)
D$class_year = as.factor(D$class_year)
D$gender = as.factor(D$gender)
D$static_con = as.factor(D$static_con)
D$causal_con = as.factor(D$causal_con)
D$soc_con = as.factor(D$soc_con)
D$dir_con = as.factor(D$dir_con)
str(D)
D$memory_check = as.factor(D$memory_check)
D$test_choice = as.factor(D$test_choice)
D$contrDir_con = as.factor(D$contrDir_con)
D$direction_choice = as.factor(D$direction_choice)
names(D)
table(D$test_choice)
table(D$test_choice)
baseline_test_sucess_prob = table(D$test_choice)[[1]]/(table(D$test_choice)[[1]]+table(D$test_choice)[[2]])
baseline_test_sucess_prob
baseline_test_success_odds = baseline_test_sucess_prob/(1-baseline_test_sucess_prob) # this is what will be shown
baseline_test_success_odds
names(D)
# direction_choice
table(D$direction_choice_lib)
baseline_direction_ordered__lib_prob = table(D$direction_choice)[[2]]/(table(D$direction_choice)[[1]]+table(D$direction_choice)[[2]])
baseline_direction_ordered__lib_prob = table(D$direction_choice_lib)[[2]]/(table(D$direction_choice_lib)[[1]]+table(D$direction_choice_lib)[[2]])
baseline_direction_ordered__lib_prob
# direction_choice
table(D$direction_choice_lib)
table(D$direction_choice_lib)
baseline_direction_ordered__lib_prob = table(D$direction_choice_lib)[[2]]/(table(D$direction_choice_lib)[[1]]+table(D$direction_choice_lib)[[2]])
baseline_direction_ordered__lib_prob
baseline_direction_ordered__lib_odds = baseline_direction_ordered__lib_prob/(1-baseline_direction_ordered__lib_prob) # this is what will be shown
baseline_direction_ordered__lib_odds
table(D$direction_choice_lib)
baseline_direction_ordered_lib_prob = table(D$direction_choice_lib)[[2]]/(table(D$direction_choice_lib)[[1]]+table(D$direction_choice_lib)[[2]])
baseline_direction_ordered_lib_prob
baseline_direction_ordered_lib_odds = baseline_direction_ordered__lib_prob/(1-baseline_direction_ordered_lib_prob) # this is what will be shown
baseline_direction_ordered_lib_odds
table(D$direction_choice_conserv)
table(D$direction_choice_conserv)[[4]]
baseline_direction_ordered_conserv_prob = table(D$direction_choice_conserv)[[1]]/(table(D$direction_choice_conserv)[[1]]+
table(D$direction_choice_conserv)[[2]]+
table(D$direction_choice_conserv)[[3]]+
table(D$direction_choice_conserv)[[4]])
baseline_direction_ordered_conserv_prob
baseline_direction_ordered_conserv_prob
baseline_direction_ordered__conserv_odds = baseline_direction_ordered_conserv_prob/(1-baseline_direction_ordered_conserv_prob) # this is what will be shown
baseline_direction_ordered__conserv_odds
table(D$control_choice)
names(D)
# control_choice
table(D$control_choice_lib)
baseline_control_ordered_lib_prob = table(D$control_choice_lib)[[2]]/(table(D$control_choice_lib)[[1]]+table(D$control_choice_lib)[[2]])
baseline_control_ordered_lib_prob
baseline_control_ordered_lib_odds = baseline_control_ordered_lib_prob/(1-baseline_control_ordered_lib_prob) # this is what will be shown
baseline_control_ordered_lib_odds
baseline_control_ordered_conserv_prob = table(D$control_choice_conserv)[[2]]/(table(D$control_choice_conserv)[[1]]+table(D$control_choice_conserv)[[2]])
baseline_control_ordered_conserv_prob
baseline_control_ordered_conserv_odds = baseline_control_ordered_conserv_prob/(1-baseline_control_ordered_conserv_prob) # this is what will be shown
baseline_control_ordered_conserv_odds
table(D$control_choice_conserv)
# control_choice
table(D$control_choice_lib)
table(D$control_choice_conserv)
baseline_control_ordered_conserv_prob = table(D$control_choice_conserv)[[1]]/(table(D$control_choice_conserv)[[1]]+
table(D$control_choice_conserv)[[2]]+
table(D$control_choice_conserv)[[3]])
baseline_control_ordered_conserv_prob
baseline_control_ordered_conserv_odds = baseline_control_ordered_conserv_prob/(1-baseline_control_ordered_conserv_prob) # this is what will be shown
baseline_control_ordered_conserv_odds
table(D$test_choice)
## liberal analyses *
# test_choice_main_analysis
D$test_choice = relevel(D$test_choice, ref="Incorrect")
glm_test_choice = glm(test_choice~1, data = D,
family = "binomial")
summary(glm_test_choice)
names(D)
glm_test_choice_full = glm(test_choice~(static_con+causal_con+soc_con+dir_con+contrDir_con)^4,
data = D,
family = "binomial")
summary(glm_test_choice_full)
glm_test_choice_full = glm(test_choice~static_con+causal_con+soc_con+dir_con+contrDir_con,
data = D,
family = "binomial")
summary(glm_test_choice_full)
glm_test_choice = glm(test_choice~1,
data = D,
family = "binomial")
summary(glm_test_choice)
names(glm_test_choice)
names(glm_test_choice)$coefficients
glm_test_choice$coefficients
exp(glm_test_choice$coefficients)
4.333333/(1+4.333333)
# control_choice_main_analysis
table(D$control_choice_lib)
levels(D$control_choice_lib)
levels(D$direction_choice_lib)
glm_direction_choice_full = glm(direction_choice~static_con+causal_con+soc_con+dir_con+contrDir_con,
data = D, family = "binomial")
glm_direction_choice_full = glm(direction_choice_lib~static_con+causal_con+soc_con+dir_con+contrDir_con,
data = D, family = "binomial")
summary(glm_direction_choice_full)
Anova(glm_direction_choice_full)
glm_direction_choice = glm(direction_choice_lib~1,
data = D, family = "binomial")
summary(glm_direction_choice)
levels(D$static_con)
multinom_direction_choice = multinom(direction_choice ~ 1, data = D)
## conservative analyses ##
multinom_direction_choice = multinom(direction_choice_conserv ~ 1, data = D)
summary(multinom_direction_choice)
multinom_direction_choice_z <- summary(multinom_direction_choice)$coefficients/summary(multinom_direction_choice)$standard.errors
multinom_direction_choice_z
multinom_direction_choice_p <- (1 - pnorm(abs(multinom_direction_choice_z), 0, 1)) * 2
multinom_direction_choice_p
levels(D$direction_choice_conserv)
table(D$direction_choice_conserv)
glm_control_choice_full = glm(control_choice ~ static_con+causal_con+soc_con+dir_con+contrDir_con,
data = D, family = "binomial")
glm_control_choice_full = glm(control_choice_lib ~ static_con+causal_con+soc_con+dir_con+contrDir_con,
data = D, family = "binomial")
summary(glm_control_choice_full)
glm_control_choice = glm(control_choice_lib ~ 1,
data = D, family = "binomial")
summary(glm_control_choice)
## liberal analyses ##
# control_choice_main_analysis
table(D$control_choice_lib)
multinom_control_choice_z <- summary(multinom_control_choice)$coefficients/summary(multinom_control_choice)$standard.errors
multinom_control_choice = multinom(control_choice_conserv ~ 1, data = D)
summary(multinom_control_choice)
## conservative analyses ##
table(D$control_choice_conserv)
multinom_control_choice_z <- summary(multinom_control_choice)$coefficients/summary(multinom_control_choice)$standard.errors
multinom_control_choice_z
multinom_control_choice_p <- (1 - pnorm(abs(multinom_control_choice_z), 0, 1)) * 2
multinom_control_choice_p
summary(glm_control_choice)
## liberal analyses ##
# control_choice_main_analysis
table(D$control_choice_lib)
exp(glm_control_choice)
exp(glm_control_choice$coefficients)
levels(D$control_choice_lib)
summary(glm_control_choice)
D$control_choice_lib = relevel(D$control_choice_lib, ref="Other")
levels(D$control_choice_lib)
D$control_choice_lib = relevel(D$control_choice_lib, ref="Order Consistent")
glm_control_choice = glm(control_choice_lib ~ 1,
data = D, family = "binomial")
summary(glm_control_choice)
exp(glm_control_choice$coefficients)
multinom_control_choice_p
multinom_control_choice_z
names(D)
mean_test_rating_correct = mean(D$test_rating_correct)
mean_test_rating_correct
sd_test_rating_correct = sd(D$test_rating_correct)
sd_test_rating_correct
mean_test_rating_incorrect = mean(D$test_rating_incorrect)
mean_test_rating_incorrect
?t.test
t_test_test_trial_ratings = t.test(D$test_rating_correct,
D$test_rating_incorrect, paired = TRUE,
alternative = "two.sided")
t_test_test_trial_ratings
names(D)
dim(D)
nrow(D)*2
D_test_rating_tall = reshape(D, varying = 10:11, v.names = "rating", timevar = "test_trial_rating", idvar = "ID",
new.row.names = 1:nrow(D)*2,
direction = "long")
D_test_rating_tall = reshape(D, varying = 10:11, v.names = "rating", timevar = "test_trial_rating", idvar = "ID",
new.row.names = 1:64,
direction = "long")
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating,
fill=test_trial_type)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun.y = mean, geom = "bar", position = "dodge")
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge")
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Rating")
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Rating") + # change the label of the y-axis
scale_y_continuous(expand = c(0, 0))
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Rating") + # change the label of the y-axis
scale_y_continuous(expand = c(0, 0)) +
coord_cartesian(ylim=c(0, 1))
test_rating_barplot = ggplot(D_test_rating_tall, aes(test_trial_rating, rating)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
test_rating_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Rating") + # change the label of the y-axis
scale_y_continuous(expand = c(0, 0)) +
coord_cartesian(ylim=c(0, 1)) +
scale_fill_manual(values = c("black", "azure3")) +
theme_bw()
